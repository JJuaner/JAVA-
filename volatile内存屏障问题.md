
# 我的困惑
volatile底层通过内存屏障来实现的，网上很多技术文章介绍了4种类型的内存屏障以及volatile读写采用了哪些内存屏障，但在学习过程中一直有疑惑：为什么是这样设计的，一直没有找到相关的详细解释为什么是这样的，下面按照我的理解重新梳理下volatile的底层原理--内存屏障。

# 正文
内存屏障有四种类型
storestore
storeload
loadload
loadstore


首先需要清晰的明确以下概念
操作类型可以分为读/写操作两种，以及volatile变量读写和普通变量读写两种


volatile的读写操作
1.为什么volatile读操作后插入了两条屏障，volatile写操作一前一后插入屏障？（感觉很不对称，当然这是从表象上而言的第一直观印象）
2.我们看到，对于volatile读操作，仅仅与volatile读之后的操作禁止重排，为什么volatile读不禁止和volatile读之前的操作发生重排？
3.volatile读操作对于之后的所有操作（包括普通读写和volatile读写）都禁止了指令重排，为什么volatile写操作只与其之后的volatile读写操作禁止重排？

当明确了这些具体的问题，加上逆向思考慢慢也就有了理解的眉目：
打开理解volatile之路的是第3个问题，为什么volatile写操作只与其之后的volatile读写操作禁止重排？
volatile变量写操作只会影响这一个volatile变量，对其他不涉及volatile变量的操作显然不会产生影响，当然也就不用禁止volatile变量和普通变量读写的指令重排。
受到这一思路的启发，类似的，对于第2个问题，我们发现，volatile读操作只可能对后面的操作产生影响，volatile读操作指令的作用域是自这条指令执行后的区间，对前面的普通操作不会影响，所以也就不需要和之前的普通操作禁止指令重排。
那么对于volatile写操作之前的内存屏障（禁止volatile写操作与之前的写操作发生指令重排），它的作用是保证在volatile写操作之前的所有写操作结果都已经刷新到主存（因为volatile变量写操作有可能基于这些写操作的结果，如果发生指令重排volatile的结果就会出现错误）
通过以上的分析，第一个问题自然而然也就可以理解了
over
